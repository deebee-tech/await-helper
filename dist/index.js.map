{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["/** Encapsulating class for all await-helpers.  All methods\n * below this are static so there does not need to be any\n * references to constructors.  This class is meant to be\n * used as a utility class for all helper methods dealing with\n * async-await.  This class is not meant to be instantiated.\n */\nexport default class AwaitHelper {\n   /** Backport an \"async-await-style\" to promise-style.  This is useful\n    * for async calls that tend to swallow errors and get lost in the\n    * promise chain.  This method will throw the error if there is one.\n    */\n   public static execute = async <T>(promise: Promise<T>): Promise<T> => {\n      return promise\n         .then<T>((data: T) => data)\n         .catch((error: Error) => {\n            throw error;\n         });\n   };\n\n   /** Execute a promise with retry logic.  This will retry the promise\n    * up to maxRetries times, waiting interval milliseconds between retries.\n    * If the promise resolves, it returns the resolved value. If it fails\n    * after all retries, it throws the last error.\n    */\n   public static executeWithRetry = async <T>(\n      promise: Promise<T>,\n      currentRetryCount?: number,\n      maxRetries?: number,\n      interval?: number,\n   ): Promise<T> => {\n      if (!currentRetryCount || typeof currentRetryCount !== \"number\") {\n         currentRetryCount = 0; // Default current retry count\n      }\n\n      if (!maxRetries || typeof maxRetries !== \"number\") {\n         maxRetries = 3; // Default retry count\n      }\n\n      if (!interval || typeof interval !== \"number\") {\n         interval = 1000; // Default retry interval\n      }\n\n      let retries = currentRetryCount;\n\n      return promise\n         .then<T>((data: T) => data)\n         .catch(async (error: Error) => {\n            if (retries < maxRetries) {\n               retries++;\n               await AwaitHelper.sleep(interval);\n               return AwaitHelper.executeWithRetry<T>(promise, retries, maxRetries, interval);\n            } else {\n               throw error;\n            }\n         });\n   };\n\n   /** Sleep for a specified number of milliseconds.  This is useful\n    * for delaying execution in async-await code.\n    */\n   private static sleep = async (ms: number) => {\n      return new Promise((resolve) => {\n         setTimeout(resolve, ms);\n      });\n   };\n}\n"],"names":[],"mappings":";;;AAMA,MAAqB,YAAA,GAArB,MAAqB,YAAA,CAAY;AA2DjC,CAAA;AAAA;AAAA;AAAA;AAAA;AAtDG,aAAA,CALkB,YAAA,EAKJ,SAAA,EAAU,OAAU,OAAA,KAAoC;AACnE,EAAA,OAAO,OAAA,CACH,KAAQ,CAAC,IAAA,KAAY,IAAI,CAAA,CACzB,KAAA,CAAM,CAAC,KAAA,KAAiB;AACtB,IAAA,MAAM,KAAA;AAAA,EACT,CAAC,CAAA;AACP,CAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,aAAA,CAlBkB,cAkBJ,kBAAA,EAAmB,OAC9B,OAAA,EACA,iBAAA,EACA,YACA,QAAA,KACc;AACd,EAAA,IAAI,CAAC,iBAAA,IAAqB,OAAO,iBAAA,KAAsB,QAAA,EAAU;AAC9D,IAAA,iBAAA,GAAoB,CAAA;AAAA,EACvB;AAEA,EAAA,IAAI,CAAC,UAAA,IAAc,OAAO,UAAA,KAAe,QAAA,EAAU;AAChD,IAAA,UAAA,GAAa,CAAA;AAAA,EAChB;AAEA,EAAA,IAAI,CAAC,QAAA,IAAY,OAAO,QAAA,KAAa,QAAA,EAAU;AAC5C,IAAA,QAAA,GAAW,GAAA;AAAA,EACd;AAEA,EAAA,IAAI,OAAA,GAAU,iBAAA;AAEd,EAAA,OAAO,OAAA,CACH,KAAQ,CAAC,IAAA,KAAY,IAAI,CAAA,CACzB,KAAA,CAAM,OAAO,KAAA,KAAiB;AAC5B,IAAA,IAAI,UAAU,UAAA,EAAY;AACvB,MAAA,OAAA,EAAA;AACA,MAAA,MAAM,YAAA,CAAY,MAAM,QAAQ,CAAA;AAChC,MAAA,OAAO,YAAA,CAAY,gBAAA,CAAoB,OAAA,EAAS,OAAA,EAAS,YAAY,QAAQ,CAAA;AAAA,IAChF,CAAA,MAAO;AACJ,MAAA,MAAM,KAAA;AAAA,IACT;AAAA,EACH,CAAC,CAAA;AACP,CAAA,CAAA;AAAA;AAAA;AAAA;AAKA,aAAA,CAtDkB,YAAA,EAsDH,OAAA,EAAQ,OAAO,EAAA,KAAe;AAC1C,EAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,KAAY;AAC7B,IAAA,UAAA,CAAW,SAAS,EAAE,CAAA;AAAA,EACzB,CAAC,CAAA;AACJ,CAAA,CAAA;AA1DH,IAAqB,WAAA,GAArB;;;;"}